// Generated by CoffeeScript 1.7.1
var $, DragState, FRAME_EDGE_SIZE, FUNC_RADIUS, GRID_SIZE, Point, Rect, Size, TargetType, addFrame, addFunc, canvas, ctx, cursorForTargetType, dragEvent, drawDragFramePreview, drawDragFuncPreview, drawFrame, drawFramePreview, drawFrames, drawFunc, drawFuncs, drawGrid, findFrameContainsPoint, findFuncContainsPoint, frames, funcs, getTarget, height, isFrameEdge, redraw, resizeFramePreview, width;

width = 960;

height = 500;

GRID_SIZE = 20;

FRAME_EDGE_SIZE = 3;

FUNC_RADIUS = GRID_SIZE / 3;

$ = function(q) {
  return document.querySelector(q);
};

canvas = document.getElementById("canvas");

ctx = canvas.getContext("2d");

Point = (function() {
  var add, sub;

  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  add = function(v) {
    if (v instanceof Point) {
      return new Point(this.x + v.x, this.y + v.y);
    } else {
      return new Point(this.x + v, this.y + v);
    }
  };

  sub = function(v) {
    if (v instanceof Point) {
      return new Point(this.x - v.x, this.y - v.y);
    } else {
      return new Point(this.x - v, this.y - v);
    }
  };

  Point.prototype.roundGrid = function() {
    return new Point(roundGrid(this.x), roundGrid(this.y));
  };

  return Point;

})();

Size = (function() {
  function Size(width, height) {
    this.width = width;
    this.height = height;
  }

  Size.fromPoint = function(point) {
    return new Size(point.x, point.y);
  };

  return Size;

})();

Rect = (function() {
  var normalize;

  function Rect(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }

  Rect.fromPoint = function(point, size) {
    return new Rect(point.x, point.y, size.width, size.height);
  };

  Rect.prototype.inset = function(dx, dy) {
    return new Rect(this.x - dx, this.y - dy, this.width + dx, this.height + dy);
  };

  Rect.prototype.contains = function(point) {
    return point.x >= this.x && point.y >= this.y && point.x <= this.x + this.width && point.y <= this.y + this.height;
  };

  Rect.prototype.setPoint = function(point) {
    this.x = point.x;
    return this.y = point.y;
  };

  Rect.prototype.setSize = function(size) {
    this.width = size.width;
    return this.height = size.height;
  };

  normalize = function(f) {
    if (this.width < 0) {
      this.x = this.x - this.width;
      this.width *= -1;
    }
    if (this.height < 0) {
      this.y = this.y - this.height;
      return this.height *= -1;
    }
  };

  return Rect;

})();

CanvasRenderingContext2D.prototype.gridPath = function(gridSize, width, height) {
  var dx, dy, x, y, _i, _j, _ref, _ref1, _results;
  for (dx = _i = 0, _ref = width / gridSize; 0 <= _ref ? _i <= _ref : _i >= _ref; dx = 0 <= _ref ? ++_i : --_i) {
    x = dx * gridSize + 0.5;
    this.moveTo(x, 0);
    this.lineTo(x, height);
  }
  _results = [];
  for (dy = _j = 0, _ref1 = height / gridSize; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; dy = 0 <= _ref1 ? ++_j : --_j) {
    y = dy * gridSize + 0.5;
    this.moveTo(0, y);
    _results.push(this.lineTo(width, y));
  }
  return _results;
};

drawGrid = function() {
  ctx.beginPath();
  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(0, 0, 0, 0.1)";
  ctx.gridPath(GRID_SIZE, width, height);
  return ctx.stroke();
};

drawFunc = function(pos, style) {
  if (style == null) {
    style = "rgba(0, 0, 0, 0.4)";
  }
  ctx.beginPath();
  ctx.arc(pos.x + 0.5, pos.y + 0.5, FUNC_RADIUS, 0, 2 * Math.PI);
  ctx.lineWidth = 2;
  ctx.strokeStyle = style;
  return ctx.stroke();
};

drawFrame = function(rect, style) {
  if (style == null) {
    style = "rgba(0, 0, 0, 0.4)";
  }
  ctx.beginPath();
  ctx.rect(rect.x + 0.5, rect.y + 0.5, rect.width, rect.height);
  ctx.lineWidth = 2;
  ctx.strokeStyle = style;
  return ctx.stroke();
};

drawFrames = function() {
  var f, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = frames.length; _i < _len; _i++) {
    f = frames[_i];
    _results.push(drawFrame(f));
  }
  return _results;
};

drawFuncs = function() {
  var f, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = funcs.length; _i < _len; _i++) {
    f = funcs[_i];
    _results.push(drawFunc(f));
  }
  return _results;
};

redraw = function() {
  var rect;
  rect = canvas.getBoundingClientRect();
  ctx.clearRect(0, 0, rect.width, rect.height);
  drawGrid();
  drawFrames();
  return drawFuncs();
};

frames = [];

funcs = [];

redraw();

DragState = {
  None: 0,
  Down: 1,
  Move: 2
};

TargetType = {
  None: 0,
  Frame: 10,
  FrameEdge: 11,
  Canvas: 20,
  Func: 30
};

dragEvent = {
  state: DragState.None,
  targetType: TargetType.None,
  target: null,
  moved: false,
  start: new Point(0, 0),
  current: new Point(0, 0)
};

canvas.onselectstart = function() {
  return false;
};

getTarget = function(pos) {
  var frame, func, target, type;
  frame = findFrameContainsPoint(pos);
  func = findFuncContainsPoint(pos);
  type = TargetType.None;
  target = null;
  if (frame != null) {
    target = frame;
    if (isFrameEdge(pos, frame)) {
      type = TargetType.FrameEdge;
    } else {
      type = TargetType.Frame;
    }
  } else if (func != null) {
    type = TargetType.Func;
    target = func;
  } else {
    type = TargetType.Canvas;
  }
  return [type, target];
};

canvas.onmousedown = function(e) {
  var _ref;
  dragEvent.state = DragState.Down;
  dragEvent.start.x = roundGrid(e.layerX);
  dragEvent.start.y = roundGrid(e.layerY);
  _ref = getTarget(dragEvent.start), dragEvent.targetType = _ref[0], dragEvent.target = _ref[1];
  return true;
};

findFuncContainsPoint = function(p) {
  var f, rect, _i, _len;
  for (_i = 0, _len = funcs.length; _i < _len; _i++) {
    f = funcs[_i];
    rect = Rect.fromPoint(f.sub(FUNC_RADIUS), Size.fromPoint(f.add(FUNC_RADIUS)));
    if (rect.contains(p)) {
      return f;
    }
  }
  return null;
};

findFrameContainsPoint = function(p, margin) {
  var f, _i, _len;
  if (margin == null) {
    margin = FRAME_EDGE_SIZE;
  }
  for (_i = 0, _len = frames.length; _i < _len; _i++) {
    f = frames[_i];
    if (f.inset(p, margin).contains(p)) {
      return f;
    }
  }
  return null;
};

isFrameEdge = function(p, f) {
  var a, b;
  a = f.inset(p, FRAME_EDGE_SIZE).contains(p);
  b = f.inset(p, -FRAME_EDGE_SIZE).contains(p);
  return a && !b;
};

addFunc = function(x, y) {
  return funcs.push(new Point(x, y));
};

addFrame = function(dragEvent) {
  return frames.push(Rect.fromPoint(dragEvent.start, Size.fromPoint(pointSub(dragEvent.current, dragEvent.start))));
};

canvas.onmouseup = function(e) {
  var offset, size, targetPos;
  switch (dragEvent.state) {
    case DragState.Down:
      addFunc(new Point(e.layerX, e.layerY).roundGrid());
      break;
    case DragState.Move:
      switch (dragEvent.targetType) {
        case TargetType.Canvas:
          addFrame(dragEvent);
          break;
        case TargetType.Frame:
          offset = pointSub(dragEvent.target, dragEvent.start);
          targetPos = pointAdd(dragEvent.current, offset);
          dragEvent.target.setPoint(targetPos);
          break;
        case TargetType.FrameEdge:
          size = Size.fromPoint(pointSub(dragEvent.current, dragEvent.target));
          dragEvent.target.setSize(size);
          break;
        case TargetType.Func:
          dragEvent.target.setSize(dragEvent.current);
      }
  }
  redraw();
  return dragEvent.state = DragState.None;
};

drawFramePreview = function(dragEvent) {
  var size;
  size = Size.fromPoint(pointSub(dragEvent.current, dragEvent.start));
  return drawFrame(Rect.fromPoint(dragEvent.start, size), "rgba(0, 0, 0, 0.2)");
};

resizeFramePreview = function(dragEvent) {
  var size;
  size = Size.fromPoint(pointSub(dragEvent.current, dragEvent.target));
  return drawFrame(Rect.fromPoint(dragEvent.target, size), "rgba(0, 0, 0, 0.2)");
};

drawDragFramePreview = function(dragEvent) {
  var pos;
  pos = pointAdd(dragEvent.current, pointSub(dragEvent.target, dragEvent.start));
  return drawFrame(Rect.fromPoint(pos, dragEvent.target), "rgba(0, 0, 0, 0.2)");
};

drawDragFuncPreview = function(dragEvent) {
  return drawFunc(dragEvent.current, "rgba(0, 0, 0, 0.2)");
};

cursorForTargetType = function(type) {
  console.log(type);
  switch (type) {
    case TargetType.Canvas:
      return "default";
    case TargetType.Func:
      return "move";
    case TargetType.Frame:
      return "move";
    case TargetType.FrameEdge:
      return "se-resize";
  }
};

canvas.onmousemove = function(e) {
  var pos;
  pos = new Point(e.layerX, e.layerY);
  if (dragEvent.state === DragState.None) {
    canvas.style.cursor = cursorForTargetType(getTarget(pos)[0]);
    return;
  } else {
    canvas.style.cursor = cursorForTargetType(dragEvent.targetType);
  }
  dragEvent.state = DragState.Move;
  dragEvent.current = pos.roundGrid();
  redraw();
  switch (dragEvent.targetType) {
    case TargetType.Canvas:
      return drawFramePreview(dragEvent);
    case TargetType.Func:
      return drawDragFuncPreview(dragEvent);
    case TargetType.Frame:
      return drawDragFramePreview(dragEvent);
    case TargetType.FrameEdge:
      return resizeFramePreview(dragEvent);
  }
};
